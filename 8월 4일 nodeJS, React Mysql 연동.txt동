

reactworkspace/management

npm install -g yarn

yarn start

		You can now view management in the browser.      

		  Local:            http://localhost:3000        
		  On Your Network:  http://192.168.0.30:3000     


src/   Components dir 생성
src/Components 		customer.js 생성

class Customer, CustomerProfile, CustomerInfo  생성

	App.js
	
	customers [] , 
	
	//loop
	customer.map(c =>{
	}
	
	
	material ui템플릿 (Mui) 설치
	
	yarn add @mui/material @emotion/react @emotion/styled     
	
	
http://127.0.0.1:55555
http:/127.0.0.1:3000

서버측에 데이터를 저장해 react 프론트로 전송..

물리적인  경로 C:\workspace\reactworkspace\management 
client 생성 git 제외하고 이동..
C:\workspace\reactworkspace\management    package.json생성

nodejs 와 react 가 동시에 실행되게끔 
{
    "name": "management",
    "version": "1.0.0",
    "scripts": {
        "client":"cd client && yarn start",													--> 클라이언트 실행 명령어
        "server":"nodemon server.js"														--> 서버 실행 명령어  (nodemon == supervisor)
		"dev": "concurrently --kill-others-on-fail \"yarn server\" \"yarn client\""			-->yarn dev명령어를통해 실행된다

    },
	//서버관련 모듈 관리 
	 "dependencies": {						"body-parser": "^1.20.0",		 
		"body-parser": "1.20.0",			   "express": "^4.18.1"
        "express": "4.18.1"
    },
	  "devDependencies": {
            "concurrently": "^4.0.1"
    }
}

https://blog.outsider.ne.kr/1041 버전입력시 ^(캐럿) ~(틸트)  의 차이...
버전의 마지막자리의 단위내에서 자동업데이트 ...   ex)  ~1.2.13-->  13단위 업데이트 자동



/client   gitignore 파일 복사>  /management  붙여넣기    깃업데이트시 무시하는 기능  



/management경로

	nodemon 설치
	npm install nodemon   >>  node_module 생성확인..
	
	실수하신듯
	글로벌하게 다시설치함...
	npm install -g nodemon
	
	
	
	server측 개발...
	
	server.js 작성
	
			const express = require('express');
			const bodyParser = require('body-parser');
			const path = require('path');

			//서버생성
			const app = express();


			//미들웨어  json형식으로 데이터 주고받을예정
			app.use(bodyParser.json());
			app.use(bodyParser.urlencoded({ extended: true }));

			//서버 테스트...  json객체형태로 데이터 전송    http://127.0.0.1:55555/app/hello   확인!
			app.get('/app/hello', function (req, res) {
				res.send({ message: 'Hello' });
			})

			//서버포트지정
			app.listen(55555, function () {
				console.log('listening on http://127.0.0.1:55555')
			});

	테스트.......................................................................
	터미널 /management   >> yarn dev 
	
	http://localhost:3000/
	http://127.0.0.1:55555/app/hello			둘다 실행됨 
	
	
	
	클라쪽 임시생성한 데이터 -> 서버쪽으로 옮겨서 json형태로 body에 보내서 확인함
	
							app.get('/api/customers', function (req, res) {
					// 클라이언트 쪽에 생성한 데이터 옮겨옴
					// json형태로 확인됨
					res.send(
						[
							{
								'id': 1,
								'image': 'https://placeimg.com/64/64/1',
								'name': '홍길동',
								'birthday': '20220101',
								'gender': '남자',
								'job': '대학생',
							},
							{
								'id': 2,
								'image': 'https://placeimg.com/64/64/2',
								'name': '김길동',
								'birthday': '20220102',
								'gender': '남자',
								'job': '개발자',
							},
							{
								'id': 3,
								'image': 'https://placeimg.com/64/64/3',
								'name': '이길동',
								'birthday': '20220103',
								'gender': '여자',
								'job': '소프트웨어 엔지니어',
							}
						]
					);
				});


프록시 수동설정 방법 
1. package.json을 통한 설정
2. yarn add http-proxy-middleware  setupProxy.js 를 통한 설정


cd ./client/		
설치		npm, yarn 차이 공부할 필요가 있음
yarn add http-proxy-middleware				npm install http-proxy-middleware // npm 사용 일 경우

		
	client/src 경로에 setupProxy.js 파일 생성
	
	
	const proxy = require('http-proxy-middleware');

	// src/setupProxy.js
	module.exports = function (app) {
		app.use(
			proxy('/posts', {
				target: 'https://jsonplaceholder.typicode.com', // 비즈니스 서버 URL 설정
				changeOrigin: true
			})
		);
	};
		


	안함 이게뭔데
	cos 설치... server.js에 모듈 추가			x 연동하려는 언어마다 cors 위배되지 않도록 하는 방식이 상이하다
											그방식중 하나로 react 에서는 proxy를 활용했고 위에 설명한것처럼 package.json설정, 프록시 수동설정, cors-middleware등등 이 있다.
	
	
	DB 연동
	
	
	async/await 키워드를 통한 비동기 코딩
	
	componentDidmount() 
	componentDidUpdate()는 갱신이 일어난 직후에 호출됩니다. 이 메서드는 최초 렌더링에서는 호출되지 않습니다.

	컴포넌트가 갱신되었을 때 DOM을 조작하기 위하여 이 메서드를 활용하면 좋습니다. 또한, 이전과 현재의 props를 비교하여 네트워크 요청을 보내는 작업도 이 메서드에서 이루어지면 됩니다 (가령, props가 변하지 않았다면 네트워크 요청을 보낼 필요가 없습니다).
	
	
	componentDidmount()  가 동작되는시점에 api에 연결해 데이터를 받아올 수 있게...
	
	
	App.js:59 Uncaught TypeError: this.state.customers.map is not a function
	서버에서 데이터를 넘겨주기 전에 클라쪽이 실행되는 비동기 이기때문에 에러가 발생한다. 
	
	기다리는 코드 필요
	임시적으로           this.state.customers ? this.state.customers.map(c => {} ):""

	
	